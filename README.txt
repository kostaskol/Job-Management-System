Προγραμματισμός Συστήματος - Εργασία 2 - Job Management System
Κωνσταντίνος Κολυβάς - 1115201200066

1. Ενδεικτική εντολή μεταγλώττισης:
    make
    Παράγονται δύο εκτελέσιμα αρχεία:
      1. jms-coord-exec
      2. jms-console-exec
      τα οποία δέχονται ορίσματα γραμμής εντολών όπως αυτά αναγράφονται στην
      εκφώνηση της εργασίας με την πρόσθεση του ορίσματος "--help"
      οπότε και εκτυπώνονται τα legal arguments.
    Επίσης παράγεται το εκτελέσιμο 'long', το οποίο δέχεται σαν όρισμα τα δευτερόλεπτα
    που θέλουμε να κάνει sleep (χρησιμοποιήθηκε για debugging)

2. Ενδεικτική εντολή εκτέλεσης:
  jms-coord-exec -l output -n max -r read_pipe -w write_pipe
  jms-console-exec -o inp/fileX.op -r write_pipe -w read_pipe

  Μόλις ολοκληρωθεί η ανάγνωση του operations file, το jms-console-exec περιμένει
  είσοδο από την γραμμή εντολών.

3. Πρωτόκολλο:
  (Για περισσότερες πληροφορίες πάνω στα πρωτόκολλα που χρησιμοποιήθηκαν βλ. PROT.txt)
  a. Πρωτόκολλο Console-Coordinator:
      Κάθε εντολή που μπορεί να δώσει ο χρήστης κωδικοποιείται σε έναν αριθμό (0-8)
      Αναλόγως με την εντολή, μπορεί να ακολουθούν περισσότεροι χαρακτήρες
      (π.χ. Η εντολή status <jid>, κωδικοποιείται ως 1<jid>)
      Αντιστοίχως κωδικοποιείται και η απάντηση από το coordinator.
      (π.χ. Η παραπάνω εντολή θα είχε ως απάντηση το 1<job-status>)

      Κάθε φορά που η console στέλνει κάποια εντολή στην coordinator, περιμένει
      και μια απάντηση. Αυτό γίνεται για να υπάρχει συγχρονισμός μεταξύ
      των ερωτοαπαντήσεων.

  b. Πρωτόκολλο Coordinator-Pools:
      1. Ακολουθείται η παραπάνω λογική. Ωστόσο η επικοινωνία του Coordinator με τα
      pools, διατηρείται στο ελάχιστο απαραίτητο, δηλαδή ο Coordinator στέλνει
      στο εκάστοτε pool τις εντολές submit - suspend - resume - kill,
      ενώ το εκάστοτε pool ενημερώνει την Coordinator για τον θάνατο κάποιου
      παιδιού. Για τον θάνατο του ίδιου του pool, η Coordinator ενημερώνεται
      μέσω signals. (βλ. 4. Signals)

      2. Όταν κάποιο παιδί κάποιου pool πεθάνει, αυτό εισέρχεται σε μία λίστα.
      Τότε, το pool προσπαθεί όσες φορές είναι απαραίτητο να ενημερώσει την
      coordinator για τον θάνατο αυτό. Εδώ, ωστόσο, εισέρχεται ένα πρόβλημα
      συγχρονισμού. (βλ. Γνωστά λάθη συγχρονισμού -> 2)

4. Χρήση πρωτοκόλλου:
      1. Κάθε μήνυμα που πρέπει να σταλεί - έχει ληφθεί πρέπει να κωδικοποιηθεί - αποκωδικοποιηθεί αντίστοιχα.
	Αυτή είναι η δουλειά της κλάσης message (shared/include/message.h). Δέχεται ένα αντικείμενο της 
	κλάσης my_vector και το μετατρέπει σε αντικείμενο της κλάσης my_string, στην περίπτωση κωδικοποίησης
	ενώ γίνεται το αντίστροφο σε περίπτωση αποκωδικοποίησης, ακολουθώντας πάντα το πρωτόκολλο
	που βρίσκεται από πάνω και, αναλυτικά, στο αρχείο PROT.txt. Αυτό γίνεται διότι είναι πιο εύκολο το "parsing" 
	μιας λίστας σε σχέση με μια συμβολοσειρά.
      2. Παράδειγμα κωδικοποίησης - αποκωδικοποίησης:
	a. Για αποστολή μηνύματος:
		i. Δημιουργούμε ένα αντικείμενο message και του παρέχουμε το αντικείμενο my_vector που πρέπει να 
		   κωδικοποιηθεί, καθώς και το πρωτόκολλο σύμφωνα με το οποίο πρέπει να το κωδικοποιήσει
		   (το τελευταίο είναι ορισμένο στο αρχείο shared/include/Constants.h)
	
		   [msg::message msg(vector, PROTOCOL);]
		ii. Καλούμε την msg::message::encode() για την κωδικοποίηση
		   [msg.encode();]

	b. Για λήψη μηνύματος:
		i. Δημιουργούμε ένα αντικείμενο message και του παρέχουμε το αντικείμενο my_string το οποίο 
		   επέστρεψε η [int pipe_manager::read_msg(my_string *)], καθώς και το πρωτόκολλο σύμφωνα με το οποίο
		   πρέπει να το κωδικοποιήσει

		   [msg::message msg(string, PROTOCOL);]
		
		ii. Καλούμε την msg::message::decode() για την αποκωδικοποίηση
		   [msg.decode()]

		iii. Καλούμε την msg::message::get_list() για να πάρουμε το αντικείμενο my_vector που δημιουργήθηκε		
		   [my_vector vec = msg.get_list();]
5. Signals:
  Signal handlers χρησιμοποιούνται από τις Pools και την Coordinator.
  Χρησιμοποιούνται:
  1. Το signal SIGCHLD για να ενημερωθούμε
    για τον θάνατο μιας υπο-διεργασίας:
      a. Στην Coordinator, ενημερωνόμαστε για τον θάνατο κάποιου pool
      b. Στις Pool, ενημερωνόμαστε για τον θάνατο κάποιου job οπότε και ενημερώνεται
         για τον θάνατο αυτού του παιδιού η Coordinator μέσω named pipe (βλ. 3. Πρωτόκολλο)
  2. Το signal SIGTERM για να ενημερώσουμε μία προς μία τις pools, οι οποίες με τη
    σειρά τους σκοτώνουν ένα προς ένα τα ενεργά παιδιά τους.

6. Γνωστά λάθη συγχρονισμού:
   1. Κάποιες φορές, για άγνωστο λόγο μετά από αρκετό debugging, η console
        τερματίζει μετά από κάποιο submit χωρίς κάποιο μήνυμα λάθους.
   2. Στα μεγάλα αρχεία, όταν οι submit εντολές έρχονται σε πολύ μικρά χρονικά διαστήματα μεταξύ τους,
	η πληροφορία πως το τελευταίο job κάποιων pool πέθανε, χάνεται.
	Αυτό συμβαίνει επειδή (με κάποιο τρόπο) πρώτα πεθαίνει το pool και μετά διαβάζει το τελευταίο του 
	μήνυμα η coordinator. 
